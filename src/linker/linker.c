#include "common.h"
#include "ldparser.h"
#include "cache.h"
#include "link.h"

#include <utillib/core.h>
#include <utillib/cli.h>
#include <utillib/utils.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

char *about_string = "This is linker for "TARGET_ARCH_NAME" CPU that can be used "\
    "to link multiple object files into one executable file. Linker "\
    "also does support static libraries generated by archiver.";

options_t *args = NULL;
settings_t settings;

static bool argparse(int argc, char **argv);
static void memclean(void);
static bool action_link(void);
static bool action_print_lds(void);

int main(int argc, char **argv){
    bool retVal = false;

    atexit_init();
    atexit_register(memclean);

    error_buffer_init(&error_buffer);

    if(argparse(argc, argv)){
        switch (settings.action) {
            case ACTION_HELP:
                options_print_help(args);
                retVal = true;
                break;
            case ACTION_VERSION:
                options_print_version(args);
                retVal = true;
                break;
            case ACTION_LINK:
                retVal = action_link();
                break;
            case ACTION_PRINT_LDS:
                retVal = action_print_lds();
                break;
            default:
                ERROR_WRITE("Action didn't specified!");
                retVal = false;
                break;
        }
    }
    else{
        retVal = false;
    }

    if(retVal == false){
        fprintf(stderr, "%s", error_buffer_get(error_buffer));
        fflush(stderr);
        return EXIT_FAILURE;
    }
    else{
        return EXIT_SUCCESS;
    }
}

bool argparse(int argc, char **argv){
    options_init(&args, VERSION, PROG_NAME);

    bool retVal = true;

    settings.action = ACTION_NOT_SPECIFIED;
    settings.verbose = false;
    settings.output_filename = NULL;
    settings.input.linker_script = NULL;
    settings.strip_unused = false;
    settings.input.input_obj_files = NULL;
    settings.input.input_sl_files = NULL;

    list_init(&settings.input.input_obj_files, sizeof(char *));
    list_init(&settings.input.input_sl_files, sizeof(char *));

    options_append_about(args, about_string);

    options_append_flag_3(args, "h", "help", "Print this help.");
    options_append_flag_2(args, "version", "Print version info.");
    options_append_string_option_3(args, "o", "output", "Set output filename.");
    options_append_string_option_3(args, "T", "linker-script", "Path to the linker script.");
    options_append_flag_2(args, "strip-unused", "Put unused sections away. Strip down output size.");
    options_append_string_option_3(args, "l", "library", "Link specified static library.");

#ifndef NDEBUG
    options_append_section(args, "Debug", NULL);
    options_append_flag_2(args, "verbose", "Be verbose during run.");
    options_append_flag_2(args, "print-lds", "Print out linker script.");
#endif

    int _argc = options_parse(args, argc, argv);
    char **_argv = options_get_argv(args);

    if(options_is_flag_set(args, "h") || options_is_flag_set(args, "help")){
        settings.action = ACTION_HELP;
        return true;
    }
    else if(options_is_flag_set(args, "version")){
        settings.action = ACTION_VERSION;
        return true;
    }
    else if(options_is_flag_set(args, "print-lds")){
        settings.action = ACTION_PRINT_LDS;
    }
    else{
        settings.action = ACTION_LINK;
    }

    if(options_is_flag_set(args, "verbose")){
        settings.verbose = true;
    }

    if(settings.action == ACTION_LINK){
        if(options_is_flag_set(args, "strip-unused")){
            settings.strip_unused = true;
        }

        if(options_is_option_set(args, "T")){
            options_get_option_value_string(args, "T", &(settings.input.linker_script));
        }
        else if(options_is_option_set(args, "linker-script")){
            options_get_option_value_string(args, "linker-script", &(settings.input.linker_script));
        }
        else{
            ERROR_WRITE("Missing path to linker script!");
            retVal = false;
        }

        if(options_is_option_set(args, "o")){
            options_get_option_value_string(args, "o", &(settings.output_filename));
        }
        else if(options_is_option_set(args, "output")){
            options_get_option_value_string(args, "output", &(settings.output_filename));
        }
        else{
            ERROR_WRITE("Missing output filename!");
            retVal = false;
        }

        list_t *short_name_list = NULL;
        list_t *long_name_list = NULL;

        if(options_is_option_set(args, "l")){
            options_get_option_multiple_values_string(args, "l", &(short_name_list));
        }

        if(options_is_option_set(args, "library")){
            options_get_option_multiple_values_string(args, "library", &(long_name_list));
        }

        if(short_name_list != NULL){
            if(list_count(short_name_list) > 0){
                list_merge( settings.input.input_sl_files, short_name_list);
            }
            list_destroy(short_name_list);
        }

        if(long_name_list != NULL){
            if(list_count(long_name_list) > 0){
                list_merge( settings.input.input_sl_files, long_name_list);
            }
            list_destroy(long_name_list);
        }

        if(_argc > 0){
            for(int i = 0; i < _argc; i++){
                list_append(settings.input.input_obj_files, (void *)(_argv + i));
            }
        }
        else{
            ERROR_WRITE("Missing input files!");
            retVal = false;
        }
    }

    if(settings.action == ACTION_PRINT_LDS){
        if(options_is_option_set(args, "T")){
            options_get_option_value_string(args, "T", &(settings.input.linker_script));
        }
        else if(options_is_option_set(args, "linker-script")){
            options_get_option_value_string(args, "linker-script", &(settings.input.linker_script));
        }
        else{
            ERROR_WRITE("Missing path to linker script!");
            retVal = false;
        }
    }

    return retVal;
}

void memclean(void){
    if(args != NULL){
        options_destroy(args);
    }

    if(error_buffer != NULL){
        error_buffer_destroy(error_buffer);
    }

    if(settings.input.input_obj_files != NULL){
        list_destroy(settings.input.input_obj_files);
    }

    if(settings.input.input_sl_files != NULL){
        list_destroy(settings.input.input_sl_files);
    }
}

static bool action_link(void){
    return linker_link();
}

static bool action_print_lds(void){
    lds_t *lds = NULL;

    LOG_MSG("Printing lds...");

    if(!parse_lds(settings.input.linker_script, &lds)){
        return false;
    }

#ifndef NDEBUG
    print_lds(lds);
    free_lds(lds);

    return true;
#else
    ERROR_WRITE("This function is avaiable only in debug mode!");
    free_lds(lds);

    return false;
#endif
}
