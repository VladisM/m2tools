/**
 * @file objread.c
 *
 * @brief Utility for reading object files.
 *
 * @author Bc. Vladislav Mlejneck√Ω <v.mlejnecky@seznam.cz>
 * @date 15.06.2019
 *
 * @note This file is part of m2tools project.
 *
 * @todo Write short manual how to use this tool. For what is used and simple overview how it work.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdbool.h>

#include <utillib/core.h>
#include <utillib/cli.h>

#include <platformlib.h>
#include <filelib.h>

typedef struct{
    char *i_file;
    bool print_symbols;
    bool print_symbol_vals;
    bool print_data;
}settings_t;

static void arg_parse(int argc, char* argv[]);
static void clean_mem(void);
static void print_obj(void);
static void failure(char *errmsg);

static settings_t settings;
options_t *args = NULL;

char *about_string = "This is simple objread utility for "TARGET_ARCH_NAME" CPU \
    that can be used to show content of object files generated by assembler.";

int main(int argc, char* argv[]){
    atexit_init();
    atexit_register(clean_mem);
    filelib_init();
    platformlib_init();

    arg_parse(argc, argv);
    print_obj();

    return 0;
}

static void arg_parse(int argc, char* argv[]){
    settings.i_file = NULL;
    settings.print_symbols = false;
    settings.print_symbol_vals = false;
    settings.print_data = false;

    options_init(&args, VERSION, PROG_NAME);
    options_append_about(args, about_string);

    options_append_flag_3(args,
        "h", "help",
        "Print this help."
    );
    options_append_flag_2(args,
        "version",
        "Print version number."
    );
    options_append_flag_3(args,
        "s", "symbol-table",
        "Print symbol table."
    );
    options_append_flag_2(args,
        "symbol-values",
        "Print values of symbol in the symbol table. This enable printing of \
        the symbol table too."
    );
    options_append_flag_3(args,
        "a", "all",
        "Print everything."
    );
    options_append_flag_2(args,
        "data",
        "Print data stored in sections."
    );

    int _argc = options_parse(args, argc, argv);
    char **_argv = options_get_argv(args);

    if(options_is_flag_set(args, "h") || options_is_flag_set(args, "help")){
        options_print_help(args);
        exit(EXIT_SUCCESS);
    }

    if(options_is_flag_set(args, "version")){
        options_print_version(args);
        exit(EXIT_SUCCESS);
    }

    if(options_is_flag_set(args, "s") || options_is_flag_set(args, "symbol-table")){
        settings.print_symbols = true;
    }

    if(options_is_flag_set(args, "symbol-values")){
        settings.print_symbol_vals = true;
        settings.print_symbols = true;
    }

    if(options_is_flag_set(args, "a") || options_is_flag_set(args, "all")){
        settings.print_symbol_vals = true;
        settings.print_symbols = true;
        settings.print_data = true;
    }

    if(options_is_flag_set(args, "data")){
        settings.print_data = true;
    }

    if(_argc != 1){
        if(_argc < 1){
            failure("Missing input file!");
        }
        else{
            failure("Too much input files given!");
        }
    }

    settings.i_file = _argv[0];
}

static void clean_mem(void){
    if(args != NULL)
        options_destroy(args);

    filelib_deinit();
    platformlib_deinit();
}

static void print_obj(void){
    obj_file_t *obj = NULL;

    if(!obj_load(settings.i_file, &obj)){
        failure(filelib_error());
    }

    printf("Object file %s\r\n", settings.i_file);
    printf(" |- arch: %s\r\n", obj->target_arch_name);

    for(unsigned i = 0; i < list_count(obj->section_list); i++){
        obj_section_t *section = NULL;
        list_at(obj->section_list, i, (void *)&section);

        bool last_section = ((i + 1) == list_count(obj->section_list))  ? true : false;
        char next_section = (last_section == true)  ? ' ' : '|';

        if(last_section == true){
            printf(" '- Section %s\r\n", section->section_name);
        }
        else{
            printf(" |- Section %s\r\n", section->section_name);
        }

        if(settings.print_symbols == true){
            printf(" %c   |- Exported:\r\n", next_section);

            if(list_count(section->exported_symbol_list) == 0){
                printf(" %c   |   '- <empty>\r\n", next_section);
            }
            else{
                for(unsigned j = 0; j < list_count(section->exported_symbol_list); j++){
                    obj_symbol_t *symbol = NULL;
                    list_at(section->exported_symbol_list, j, (void *)&symbol);

                    char *value = platformlib_write_isa_address(symbol->value);
                    char next_symbol = ((j + 1) != list_count(section->exported_symbol_list))  ? '|' : '\'';

                    if(settings.print_symbol_vals == true){
                        printf(" %c   |   %c- %s %s\r\n", next_section, next_symbol, symbol->name, value);
                    }
                    else{
                        printf(" %c   |   %c- %s\r\n", next_section, next_symbol, symbol->name);
                    }

                    dynmem_free(value);
                }
            }

            char dataprint_symbol = (settings.print_data == true) ? '|' : ' ';

            if(settings.print_data == true){
                printf(" %c   |- Imported:\r\n", next_section);
            }
            else{
                printf(" %c   '- Imported:\r\n", next_section);
            }

            if(list_count(section->imported_symbol_list) == 0){
                printf(" %c   %c   '- <empty>\r\n", next_section, dataprint_symbol);
            }
            else{
                for(unsigned j = 0; j < list_count(section->imported_symbol_list); j++){
                    obj_symbol_t *symbol = NULL;
                    list_at(section->imported_symbol_list, j, (void *)&symbol);

                    char *value = platformlib_write_isa_address(symbol->value);
                    char next_symbol = ((j + 1) != list_count(section->imported_symbol_list))  ? '|' : '\'';

                    if(settings.print_symbol_vals == true){
                        printf(" %c   %c   %c- %s %s\r\n", next_section, dataprint_symbol, next_symbol, symbol->name, value);
                    }
                    else{
                        printf(" %c   %c   %c- %s\r\n", next_section, dataprint_symbol, next_symbol, symbol->name);
                    }


                    dynmem_free(value);
                }
            }
        }

        if(settings.print_data == true){
            printf(" %c   '- Data:\r\n", next_section);

            if(list_count(section->data_symbol_list) == 0){
                printf(" %c       '- <empty>\r\n", next_section);
            }
            else{
                for(unsigned j = 0; j < list_count(section->data_symbol_list); j++){
                    obj_data_t *symbol = NULL;
                    list_at(section->data_symbol_list, j, (void *)&symbol);

                    char *address = platformlib_write_isa_address(symbol->address);
                    char *value = NULL;
                    char next_data = ((j + 1) != list_count(section->data_symbol_list))  ? '|' : '\'';

                    if(symbol->blob == true){
                        value = platformlib_write_isa_memory_element(symbol->payload.blob_value);
                        printf(" %c       %c- blob %s %s\r\n", next_section, next_data, address, value);
                    }
                    else{
                        value = platformlib_write_isa_instruction_word(symbol->payload.data_value);
                        char *relocation = symbol->relocation ? "1" : "0";
                        char *special = symbol->special ? "1" : "0";
                        printf(" %c       %c- inst %s %s relocation:%s special:%s\r\n", next_section, next_data, address, value, relocation, special);
                    }

                    dynmem_free(address);
                    dynmem_free(value);
                }
            }
        }

    }

    obj_file_destroy(obj);
}

static void failure(char *errmsg){
    fprintf(stderr, "%s\r\n", errmsg);
    fflush(stderr);
    exit(EXIT_FAILURE);
}
